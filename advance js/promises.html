<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //1-creating  a promise
      let promise1 = new Promise(function (resolve, reject) {
        setTimeout(function () {
          console.log("Async task completed");
          resolve(); // Call resolve to indicate that the task has been completed successfully
          console.log(typeof promise1);
        }, 2000);
      });
      //2-to consume a promise we will use .then,.catch like methods whihc is mentioned as below
      promise1.then(function () {
        console.log("promise is consumed ");
      });
      new Promise(function (resolve, reject) {
        setTimeout(function () {
          console.log("async task 2 is done now");
          resolve();
        }, 1000);
      }).then(function () {
        console.log("promsie has been consumed succesfully");
      });
      //3-there are many of the times we are finding ourselves using promises in a function which is giving a data from a database,in short the .then is connected with resolve that means when we pass something fromm the resolve argument we will get that same in the .then,
      let promsie2=new Promise(function(resolve,reject){
        setTimeout(function(){
            console.log("data loaded suceesfully");
            resolve({username:"debanshu pati",occupanccy:"developer",age:34,dob:"10 sep 2005"});
        },2000)
      })
      promsie2.then(function(userDetails){
        console.log(userDetails)
      });
      let promise3 = new Promise(function(resolve, reject) {
    setTimeout(function() {
        let error = false;
        if (!error) {
            resolve({username: "slayer", occupanccy: "developer, programmer", age: 18, dob: "10 April 2005"});
        } else {
            reject(error);
        }
    }, 1500);
});

promise3.then(function(userInputs) {
    console.log(userInputs);
    return userInputs.occupanccy; // Return the occupancy value
}).then(function(occupanccy) {
    console.log(occupanccy); //   // console.log(occupancy);this will no print as the variables defined inside the functions(let) are blocked scoped and if we tried it by( var) it wikll not even print it as var is fucntioned scoped meaning it cant be ascessed outside the fucntion from where it is created.
    
}).catch(function(error) {
    console.log(error);
}).finally(function(){
    console.log("prosmise has been eiteher resolved or rejected")
});//finally is used to conclude the promise whether it is resolved or rejected.
// async await = promises + syntax for handling asynchronous code in a more synchronous way. Itâ€™s not part of ES6 but rather added in ES8.it is more like.catch and .then it just throws the error if it is not used with catch in case of a error
//moreover finally is very useful in case of functions where we have used returned keyword after tahat we ant to show the messages finally will run it 
let promise4 = new Promise(function(resolve, reject) {
    setTimeout(function() {
        let error = false;
        if (!error) {
            resolve({username: "debanshu pati", occupanccy: "developer", age: 34, dob: "10 Sep 2005"});
        } else {
            reject(("Error occurred: Promise rejected"));
        }
    }, 1000); // Specify the timeout value in milliseconds
});

async function consumePromise4() {
    try {
        let response = await promise4;
        console.log(response);
    } catch (error) {
        console.log(error);
    }
}

// consumePromise4(); // Call the async function to consume the promise

//steps to handle promises through async await                                                                
// async functionname(parameter){
//     let variable=await promisename
//     remaining works!!!!
// }
// important note: 
// In traditional promise syntax using .then() and .catch(), the promise chain starts executing immediately after the promise is created, and you don't need to explicitly call a function to start the execution.However, with async/await, you need to explicitly call the function marked with async to initiate the execution of asynchronous code within that function. This is because async/await is a syntactic sugar built on top of promises, allowing you to write asynchronous code in a more synchronous-looking style.

async function hiteshsir(){
   try {
    const response = await fetch('https://api.github.com/users/hiteshchoudhary')
              const data=     await response.json()
              console.log(data);
   } catch (error) {
    console.log('error something went wrong please try agian',error);
   }
}
// hiteshsir();
//by traditional method
fetch('https://api.github.com/users/hiteshchoudhary')
.then(function(response){
   return response.json();//in traditional method we cant just put the responses form the api to the variable and use it it is only possible in async await hence in now a days it is used the most
  
}).then(function(data){
    console.log(data);
})
.catch(function(error){
    console.log("error something happended wrong",error)
})
      
    </script>
  </body>
</html>
